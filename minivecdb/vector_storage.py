"""This notebook explores the VectorStorage class, which is the foundation of our MiniVecDB project. The VectorStorage class provides a simple yet effective way to store, retrieve, and manage vector embeddings along with their associated metadata"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_vector_storage.ipynb.

# %% auto 0
__all__ = ['VectorStorage']

# %% ../nbs/00_vector_storage.ipynb 5
import numpy as np
import json
from typing import Dict, List, Any, Tuple, Union
import fastcore.all as fc

# %% ../nbs/00_vector_storage.ipynb 7
class VectorStorage:
    def __init__(self, dimension):
        fc.store_attr()
        self.vectors = {}  # id -> vector
        self.metadatas = {}  # id -> metadata
        self.next_id = 0
    
    def add(self, vector, metadata):
        fc.test_eq(self.dimension, len(vector))
        current_id = self.next_id
        self.vectors[current_id] = vector
        self.metadatas[current_id] = metadata
        self.next_id += 1
        return current_id
    
    def get(self, id): return (self.vectors[id], self.metadatas[id])
    
    def delete(self, id):
        if id not in self.vectors: return False
        self.vectors.pop(id)
        self.metadatas.pop(id)
        return True
    
    def get_all(self): return fc.L((key, self.vectors[key], self.metadatas[key]) for key in self.vectors)
        
    
    def save(self, filepath):
        data = {
            'dimension': self.dimension,
            'next_id': self.next_id,
            'vectors': {str(k): v.tolist() for k, v in self.vectors.items()},
            'metadatas': self.metadatas  # This should already be serializable
        }
        fc.Path(filepath).write_text(fc.dumps(data))
    
    @classmethod
    def load(cls, filepath):
        data = fc.Path(filepath).read_json()
        
        storage = cls(data['dimension'])
        storage.next_id = data['next_id']
        
        storage.vectors = {int(k): np.array(v) for k, v in data['vectors'].items()}
        storage.metadatas = {int(k): v for k, v in data['metadatas'].items()}
        
        return storage
